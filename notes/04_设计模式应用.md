# Qwen-Agent 设计模式应用详解

## 1. 设计模式概述

Qwen-Agent 作为一个企业级 LLM 应用开发框架，巧妙地应用了多种设计模式来解决复杂的软件设计问题。本文将深入分析各种设计模式在框架中的具体应用场景、实现方式和优势。

### 1.1 设计模式分类

**创建型模式**:
- 抽象工厂模式 (Abstract Factory)
- 建造者模式 (Builder)
- 单例模式 (Singleton)

**结构型模式**:
- 装饰器模式 (Decorator)
- 适配器模式 (Adapter)
- 外观模式 (Facade)

**行为型模式**:
- 策略模式 (Strategy)
- 观察者模式 (Observer)
- 命令模式 (Command)
- 状态模式 (State)
- 模板方法模式 (Template Method)

## 2. 创建型模式应用

### 2.1 抽象工厂模式

#### 2.1.1 Agent 抽象工厂

```python
# qwen_agent/agent.py
from abc import ABC, abstractmethod
from typing import Iterator, List, Optional, Union, Dict

class Agent(ABC):
    """智能体抽象工厂基类"""
    
    def __init__(self, 
                 function_list: Optional[List[Union[str, Dict]]] = None,
                 llm: Optional[Union[Dict, 'BaseChatModel']] = None,
                 system_message: Optional[str] = None,
                 name: Optional[str] = None,
                 description: Optional[str] = None,
                 **kwargs):
        # 统一的初始化逻辑
        self.llm = get_chat_model(llm) if isinstance(llm, dict) else llm
        self.function_map = {}
        self.system_message = system_message
        self.name = name
        self.description = description
        
        # 工具初始化
        if function_list:
            for tool in function_list:
                self._init_tool(tool)
    
    @abstractmethod
    def _run(self, messages: List['Message'], **kwargs) -> Iterator[List['Message']]:
        """抽象工厂方法 - 子类必须实现具体的智能体逻辑"""
        raise NotImplementedError
    
    def run(self, messages: List['Message'], **kwargs) -> Iterator[List['Message']]:
        """模板方法 - 定义智能体执行的标准流程"""
        # 预处理
        processed_messages = self._preprocess_messages(messages)
        
        # 执行具体逻辑
        yield from self._run(processed_messages, **kwargs)
        
        # 后处理
        yield from self._postprocess_results()
```

**模式应用分析**:
- **抽象工厂**: `Agent` 基类定义了所有智能体的统一接口
- **模板方法**: `run()` 方法定义了标准执行流程
- **扩展性**: 子类只需实现 `_run()` 方法即可创建新智能体

#### 2.1.2 LLM 抽象工厂

```python
# qwen_agent/llm/base.py
from abc import ABC, abstractmethod
from typing import Dict, Iterator, List, Optional, Union

class BaseChatModel(ABC):
    """LLM 抽象工厂基类"""
    
    def __init__(self, cfg: Optional[Dict] = None):
        self.cfg = cfg or {}
        self.model = self.cfg.get('model', '')
        self.model_type = self.cfg.get('model_type', '')
        self.api_key = self.cfg.get('api_key', '')
        self._init_model()
    
    def _init_model(self):
        """初始化模型的具体实现"""
        pass
    
    @abstractmethod
    def _chat_stream(self, messages: List['Message'], 
                    delta_stream: bool, generate_cfg: Dict) -> Iterator[List['Message']]:
        """流式聊天抽象方法"""
        raise NotImplementedError
    
    @abstractmethod
    def _chat_no_stream(self, messages: List['Message'], 
                       generate_cfg: Dict) -> List['Message']:
        """非流式聊天抽象方法"""
        raise NotImplementedError
    
    def chat(self, messages: List[Union['Message', Dict]], 
            functions: Optional[List[Dict]] = None,
            stream: bool = True,
            delta_stream: bool = False,
            extra_generate_cfg: Optional[Dict] = None,
            ) -> Union[List['Message'], List[Dict], Iterator[List['Message']], Iterator[List[Dict]]]:
        """统一的聊天接口 - 模板方法"""
        # 参数标准化
        standardized_messages = self._standardize_messages(messages)
        generate_cfg = self._merge_generate_cfg(extra_generate_cfg)
        
        # 选择执行方式
        if stream:
            return self._chat_stream(standardized_messages, delta_stream, generate_cfg)
        else:
            return self._chat_no_stream(standardized_messages, generate_cfg)
```

**具体工厂实现**:

```python
# qwen_agent/llm/qwen_dashscope.py
@register_llm('qwen_dashscope')
class QwenChatAtDashScope(BaseChatModel):
    """Qwen 模型具体工厂"""
    
    def _chat_stream(self, messages, delta_stream, generate_cfg):
        """实现流式聊天"""
        # 具体的 Qwen API 调用逻辑
        responses = self._call_qwen_api(messages, stream=True, **generate_cfg)
        for response in responses:
            yield self._parse_response(response, delta_stream)
    
    def _chat_no_stream(self, messages, generate_cfg):
        """实现非流式聊天"""
        response = self._call_qwen_api(messages, stream=False, **generate_cfg)
        return self._parse_response(response, False)

# qwen_agent/llm/oai.py
@register_llm('oai')
class OpenAIChat(BaseChatModel):
    """OpenAI 兼容模型具体工厂"""
    
    def _chat_stream(self, messages, delta_stream, generate_cfg):
        """实现 OpenAI 流式聊天"""
        responses = self._call_openai_api(messages, stream=True, **generate_cfg)
        for response in responses:
            yield self._parse_response(response, delta_stream)
    
    def _chat_no_stream(self, messages, generate_cfg):
        """实现 OpenAI 非流式聊天"""
        response = self._call_openai_api(messages, stream=False, **generate_cfg)
        return self._parse_response(response, False)
```

**模式优势**:
- **统一接口**: 所有模型提供者实现相同的接口
- **易于扩展**: 新增模型提供商只需实现抽象方法
- **客户端解耦**: 使用方无需关心具体模型实现

### 2.2 建造者模式

#### 2.2.1 消息构建器

```python
# qwen_agent/llm/schema.py
from typing import Optional, Union, List
from pydantic import BaseModel, Field

class FunctionCall(BaseModel):
    """函数调用对象"""
    name: str = Field(..., description="函数名称")
    arguments: str = Field(..., description="函数参数(JSON字符串)")

class ContentItem(BaseModel):
    """多模态内容项"""
    type: str = Field(..., description="内容类型")
    text: Optional[str] = Field(None, description="文本内容")
    image: Optional[str] = Field(None, description="图像URL或base64")
    audio: Optional[str] = Field(None, description="音频URL或base64")
    file_url: Optional[str] = Field(None, description="文件URL")

class MessageBuilder:
    """消息建造者"""
    
    def __init__(self):
        self.reset()
    
    def reset(self):
        """重置建造者"""
        self._role = "user"
        self._content = ""
        self._name = None
        self._function_call = None
        self._content_items = []
        return self
    
    def with_role(self, role: str):
        """设置消息角色"""
        self._role = role
        return self
    
    def with_content(self, content: str):
        """设置文本内容"""
        self._content = content
        return self
    
    def with_name(self, name: str):
        """设置发送者名称"""
        self._name = name
        return self
    
    def with_function_call(self, function_call: FunctionCall):
        """设置函数调用"""
        self._function_call = function_call
        return self
    
    def add_text_content(self, text: str):
        """添加文本内容项"""
        self._content_items.append(ContentItem(type="text", text=text))
        return self
    
    def add_image_content(self, image_url: str):
        """添加图像内容项"""
        self._content_items.append(ContentItem(type="image", image=image_url))
        return self
    
    def add_audio_content(self, audio_url: str):
        """添加音频内容项"""
        self._content_items.append(ContentItem(type="audio", image=audio_url))
        return self
    
    def build(self) -> 'Message':
        """构建消息对象"""
        content = self._content if self._content else self._content_items
        
        message = Message(
            role=self._role,
            content=content,
            name=self._name,
            function_call=self._function_call
        )
        
        self.reset()  # 构建完成后重置
        return message

# 使用示例
message = (MessageBuilder()
    .with_role("user")
    .with_content("请分析这张图片")
    .add_image_content("https://example.com/image.jpg")
    .build())
```

**模式特点**:
- **链式调用**: 支持流畅的链式API设计
- **分步构建**: 复杂对象的分步构建过程
- **类型安全**: 通过建造者确保对象完整性

#### 2.2.2 智能体配置构建器

```python
class AgentConfigBuilder:
    """智能体配置建造者"""
    
    def __init__(self):
        self.reset()
    
    def reset(self):
        """重置配置"""
        self._config = {
            'name': '',
            'description': '',
            'instructions': '',
            'function_list': [],
            'knowledge_files': [],
            'llm_config': {},
            'rag_config': {}
        }
        return self
    
    def with_name(self, name: str):
        """设置智能体名称"""
        self._config['name'] = name
        return self
    
    def with_description(self, description: str):
        """设置智能体描述"""
        self._config['description'] = description
        return self
    
    def with_instructions(self, instructions: str):
        """设置指令"""
        self._config['instructions'] = instructions
        return self
    
    def add_function(self, function_name: str, **kwargs):
        """添加工具函数"""
        self._config['function_list'].append({
            'name': function_name,
            **kwargs
        })
        return self
    
    def add_knowledge_file(self, file_path: str):
        """添加知识库文件"""
        self._config['knowledge_files'].append(file_path)
        return self
    
    def with_llm_config(self, **config):
        """设置LLM配置"""
        self._config['llm_config'].update(config)
        return self
    
    def with_rag_config(self, **config):
        """设置RAG配置"""
        self._config['rag_config'].update(config)
        return self
    
    def build(self) -> Dict:
        """构建配置字典"""
        config = self._config.copy()
        self.reset()
        return config
```

### 2.3 单例模式

#### 2.3.1 注册器单例

```python
# qwen_agent/llm/base.py
from typing import Dict, Type

class LLMRegistry:
    """LLM 注册器单例"""
    
    _instance = None
    _registry: Dict[str, Type['BaseChatModel']] = {}
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    @classmethod
    def register(cls, model_type: str):
        """注册模型类型"""
        def decorator(model_class: Type['BaseChatModel']):
            cls._registry[model_type] = model_class
            return model_class
        return decorator
    
    @classmethod
    def get_model_class(cls, model_type: str) -> Type['BaseChatModel']:
        """获取模型类"""
        if model_type not in cls._registry:
            raise ValueError(f"Unknown model type: {model_type}")
        return cls._registry[model_type]
    
    @classmethod
    def list_models(cls) -> List[str]:
        """列出所有注册的模型类型"""
        return list(cls._registry.keys())

# 使用装饰器注册
def register_llm(model_type):
    """LLM 注册装饰器"""
    return LLMRegistry.register(model_type)

# 全局注册表实例
LLM_REGISTRY = LLMRegistry()
```

**模式特点**:
- **全局唯一**: 确保注册器全局唯一
- **线程安全**: 通过 `__new__` 方法确保线程安全
- **延迟初始化**: 首次使用时才创建实例

## 3. 结构型模式应用

### 3.1 装饰器模式

#### 3.1.1 智能体功能装饰

```python
# qwen_agent/agents/assistant.py
class Assistant(FnCallAgent):
    """装饰器模式：在 FnCallAgent 基础上添加 RAG 功能"""
    
    def __init__(self, function_list=None, llm=None, system_message=None, 
                 files=None, rag_cfg=None, **kwargs):
        # 调用父类构造函数
        super().__init__(function_list=function_list, llm=llm, system_message=system_message)
        
        # 添加 RAG 功能
        self.rag_enabled = rag_cfg is not None
        if self.rag_enabled:
            self.mem = Memory(llm=llm, files=files, **rag_cfg)
            self.rag_cfg = rag_cfg
    
    def _run(self, messages: List[Message], lang='en', knowledge='', **kwargs):
        """装饰后的运行方法"""
        # 预处理：注入 RAG 知识
        if self.rag_enabled and not knowledge:
            new_messages = self._prepend_knowledge_prompt(
                messages=messages, lang=lang, knowledge=knowledge, **kwargs)
        else:
            new_messages = messages
        
        # 调用被装饰的方法
        yield from super()._run(messages=new_messages, lang=lang, **kwargs)
    
    def _prepend_knowledge_prompt(self, messages, lang, knowledge, **kwargs):
        """RAG 知识注入装饰逻辑"""
        if not knowledge:
            # 从记忆中检索知识
            *_, last = self.mem.run(messages=messages, lang=lang, **kwargs)
            knowledge = last[-1].content if last else ''
        
        if knowledge:
            # 格式化知识并注入到系统消息中
            knowledge_prompt = self._format_knowledge_prompt(knowledge, lang)
            
            if messages and messages[0].role == 'system':
                messages[0].content += '\n\n' + knowledge_prompt
            else:
                messages = [Message(role='system', content=knowledge_prompt)] + messages
        
        return messages
    
    def _format_knowledge_prompt(self, knowledge: str, lang: str) -> str:
        """格式化知识提示"""
        templates = {
            'en': "Reference information:\n{knowledge}\n\nPlease use the above information to answer the user's question.",
            'zh': "参考信息：\n{knowledge}\n\n请使用以上信息回答用户的问题。"
        }
        return templates.get(lang, templates['en']).format(knowledge=knowledge)
```

#### 3.1.2 缓存装饰器

```python
# qwen_agent/utils/cache.py
import functools
import json
import hashlib
from typing import Any, Callable, Optional

def cache_result(expire_time: Optional[int] = None, key_prefix: str = ""):
    """缓存装饰器"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 生成缓存键
            cache_key = _generate_cache_key(func.__name__, args, kwargs, key_prefix)
            
            # 尝试从缓存获取
            cached_result = _get_from_cache(cache_key, expire_time)
            if cached_result is not None:
                return cached_result
            
            # 执行函数并缓存结果
            result = func(*args, **kwargs)
            _set_to_cache(cache_key, result, expire_time)
            
            return result
        return wrapper
    return decorator

def _generate_cache_key(func_name: str, args: tuple, kwargs: dict, prefix: str) -> str:
    """生成缓存键"""
    # 序列化参数
    key_data = {
        'func': func_name,
        'args': args,
        'kwargs': kwargs
    }
    key_str = json.dumps(key_data, sort_keys=True, default=str)
    
    # 生成哈希
    hash_obj = hashlib.md5(key_str.encode())
    return f"{prefix}{hash_obj.hexdigest()}"

def retry_on_failure(max_retries: int = 3, delay: float = 1.0, 
                    exceptions: tuple = (Exception,)):
    """重试装饰器"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    if attempt == max_retries - 1:
                        raise e
                    time.sleep(delay * (2 ** attempt))  # 指数退避
            return None
        return wrapper
    return decorator

# 使用示例
@cache_result(expire_time=3600, key_prefix="llm_call_")
@retry_on_failure(max_retries=3, delay=1.0)
def call_llm_api(messages: List[Message], **kwargs):
    """调用 LLM API 的装饰方法"""
    # 原始 API 调用逻辑
    return llm_client.chat(messages, **kwargs)
```

**模式特点**:
- **功能增强**: 在不修改原有代码的情况下添加新功能
- **透明装饰**: 对客户端透明，保持原有接口
- **组合装饰**: 支持多个装饰器组合使用

### 3.2 适配器模式

#### 3.2.1 消息格式适配器

```python
class MessageAdapter:
    """消息格式适配器"""
    
    @staticmethod
    def adapt_to_qwen_format(messages: List[Union[Dict, 'Message']]) -> List['Message']:
        """适配为 Qwen 格式"""
        adapted_messages = []
        
        for msg in messages:
            if isinstance(msg, dict):
                # 字典格式转换为 Message 对象
                adapted_msg = Message(
                    role=msg.get('role', 'user'),
                    content=msg.get('content', ''),
                    name=msg.get('name'),
                    function_call=msg.get('function_call')
                )
            else:
                # 已经是 Message 对象，直接使用
                adapted_msg = msg
            
            adapted_messages.append(adapted_msg)
        
        return adapted_messages
    
    @staticmethod
    def adapt_to_openai_format(messages: List['Message']) -> List[Dict]:
        """适配为 OpenAI 格式"""
        adapted_messages = []
        
        for msg in messages:
            openai_msg = {
                'role': msg.role,
                'content': msg.content
            }
            
            if msg.name:
                openai_msg['name'] = msg.name
            
            if msg.function_call:
                openai_msg['function_call'] = {
                    'name': msg.function_call.name,
                    'arguments': msg.function_call.arguments
                }
            
            adapted_messages.append(openai_msg)
        
        return adapted_messages
    
    @staticmethod
    def adapt_content_format(content: Union[str, List['ContentItem']]) -> str:
        """适配内容格式"""
        if isinstance(content, str):
            return content
        
        # 多模态内容转换为文本描述
        text_parts = []
        for item in content:
            if item.type == 'text' and item.text:
                text_parts.append(item.text)
            elif item.type == 'image':
                text_parts.append(f"[Image: {item.image or 'attached'}]")
            elif item.type == 'audio':
                text_parts.append(f"[Audio: {item.audio or 'attached'}]")
        
        return ' '.join(text_parts)
```

#### 3.2.2 LLM 接口适配器

```python
class LLMAdapter:
    """LLM 接口适配器"""
    
    def __init__(self, model: 'BaseChatModel'):
        self.model = model
    
    def adapt_openai_compatible(self, messages: List[Dict], **kwargs) -> Dict:
        """适配为 OpenAI 兼容格式"""
        # 转换消息格式
        qwen_messages = MessageAdapter.adapt_to_qwen_format(messages)
        
        # 调用 Qwen 模型
        response = list(self.model.chat(qwen_messages, **kwargs))
        
        # 转换响应格式
        return self._adapt_openai_response(response)
    
    def _adapt_openai_response(self, response: List['Message']) -> Dict:
        """适配响应格式"""
        if not response:
            return {'choices': []}
        
        last_message = response[-1]
        
        return {
            'choices': [{
                'index': 0,
                'message': {
                    'role': last_message.role,
                    'content': MessageAdapter.adapt_content_format(last_message.content)
                },
                'finish_reason': 'stop'
            }],
            'usage': {
                'prompt_tokens': 0,  # 需要从实际响应中获取
                'completion_tokens': 0,
                'total_tokens': 0
            }
        }
```

### 3.3 外观模式

#### 3.3.1 智能体管理外观

```python
class AgentManager:
    """智能体管理外观类"""
    
    def __init__(self):
        self._agents = {}
        self._tools = {}
        self._llm_configs = {}
    
    def create_agent(self, agent_type: str, name: str, **config) -> 'Agent':
        """创建智能体的统一接口"""
        if agent_type == 'assistant':
            return self._create_assistant(name, **config)
        elif agent_type == 'react':
            return self._create_react_agent(name, **config)
        elif agent_type == 'group_chat':
            return self._create_group_chat(name, **config)
        else:
            raise ValueError(f"Unknown agent type: {agent_type}")
    
    def _create_assistant(self, name: str, **config) -> 'Assistant':
        """创建助手智能体"""
        llm = self._get_llm_model(config.get('llm_config', {}))
        function_list = self._prepare_function_list(config.get('functions', []))
        
        return Assistant(
            name=name,
            description=config.get('description', ''),
            function_list=function_list,
            llm=llm,
            system_message=config.get('system_message', ''),
            files=config.get('files', []),
            rag_cfg=config.get('rag_config', {})
        )
    
    def _create_react_agent(self, name: str, **config) -> 'ReActChat':
        """创建 ReAct 智能体"""
        llm = self._get_llm_model(config.get('llm_config', {}))
        function_list = self._prepare_function_list(config.get('functions', []))
        
        return ReActChat(
            name=name,
            description=config.get('description', ''),
            function_list=function_list,
            llm=llm,
            system_message=config.get('system_message', '')
        )
    
    def _create_group_chat(self, name: str, **config) -> 'GroupChat':
        """创建群聊智能体"""
        agents_config = config.get('agents', [])
        agents = []
        
        for agent_config in agents_config:
            agent = self.create_agent(
                agent_config.get('type', 'assistant'),
                agent_config.get('name'),
                **agent_config
            )
            agents.append(agent)
        
        return GroupChat(
            agents=agents,
            agent_selection_method=config.get('selection_method', 'auto'),
            name=name,
            description=config.get('description', '')
        )
    
    def _get_llm_model(self, llm_config: Dict) -> 'BaseChatModel':
        """获取 LLM 模型"""
        model_type = llm_config.get('model_type', 'qwen_dashscope')
        model_class = LLM_REGISTRY.get_model_class(model_type)
        return model_class(cfg=llm_config)
    
    def _prepare_function_list(self, functions: List[Union[str, Dict]]) -> List[Dict]:
        """准备函数列表"""
        prepared_functions = []
        
        for func in functions:
            if isinstance(func, str):
                # 工具名称转换为工具配置
                prepared_functions.append({'name': func})
            else:
                # 已经是工具配置
                prepared_functions.append(func)
        
        return prepared_functions
```

**模式特点**:
- **简化接口**: 提供统一的创建接口
- **隐藏复杂性**: 封装复杂的创建逻辑
- **易于使用**: 客户端只需调用简单方法

## 4. 行为型模式应用

### 4.1 策略模式

#### 4.1.1 智能体选择策略

```python
# qwen_agent/agents/group_chat.py
from abc import ABC, abstractmethod
from typing import List, Optional
import random

class AgentSelectionStrategy(ABC):
    """智能体选择策略抽象基类"""
    
    @abstractmethod
    def select_agent(self, agents: List['Agent'], messages: List['Message'], 
                    mentioned_agents: List[str], **kwargs) -> 'Agent':
        """选择智能体的抽象方法"""
        raise NotImplementedError

class ManualSelectionStrategy(AgentSelectionStrategy):
    """手动选择策略"""
    
    def select_agent(self, agents: List['Agent'], messages: List['Message'], 
                    mentioned_agents: List[str], **kwargs) -> 'Agent':
        """根据提到的智能体名称选择"""
        if mentioned_agents:
            agent_map = {agent.name: agent for agent in agents}
            return agent_map[mentioned_agents[0]]
        
        # 如果没有提到任何智能体，返回第一个
        return agents[0]

class RoundRobinSelectionStrategy(AgentSelectionStrategy):
    """轮询选择策略"""
    
    def __init__(self):
        self.last_index = -1
    
    def select_agent(self, agents: List['Agent'], messages: List['Message'], 
                    mentioned_agents: List[str], **kwargs) -> 'Agent':
        """轮询选择智能体"""
        if mentioned_agents:
            agent_map = {agent.name: agent for agent in agents}
            return agent_map[mentioned_agents[0]]
        
        # 轮询选择
        self.last_index = (self.last_index + 1) % len(agents)
        return agents[self.last_index]

class RandomSelectionStrategy(AgentSelectionStrategy):
    """随机选择策略"""
    
    def select_agent(self, agents: List['Agent'], messages: List['Message'], 
                    mentioned_agents: List[str], **kwargs) -> 'Agent':
        """随机选择智能体"""
        if mentioned_agents:
            agent_map = {agent.name: agent for agent in agents}
            return agent_map[mentioned_agents[0]]
        
        # 随机选择
        return random.choice(agents)

class AutoSelectionStrategy(AgentSelectionStrategy):
    """自动选择策略"""
    
    def __init__(self, router_agent: 'Agent'):
        self.router_agent = router_agent
    
    def select_agent(self, agents: List['Agent'], messages: List['Message'], 
                    mentioned_agents: List[str], **kwargs) -> 'Agent':
        """基于上下文自动选择智能体"""
        if mentioned_agents:
            agent_map = {agent.name: agent for agent in agents}
            return agent_map[mentioned_agents[0]]
        
        # 使用路由器智能体选择
        *_, last = self.router_agent.run(messages=messages, **kwargs)
        selected_name = last[-1].content.strip() if last else agents[0].name
        
        agent_map = {agent.name: agent for agent in agents}
        return agent_map.get(selected_name, agents[0])

class GroupChat(Agent):
    """群聊智能体 - 使用策略模式"""
    
    def __init__(self, agents, agent_selection_method='auto', **kwargs):
        super().__init__(**kwargs)
        
        # 初始化策略
        self.strategies = {
            'manual': ManualSelectionStrategy(),
            'round_robin': RoundRobinSelectionStrategy(),
            'random': RandomSelectionStrategy(),
        }
        
        if agent_selection_method == 'auto':
            # 自动模式需要路由器
            self.host = GroupChatAutoRouter(
                function_list=function_list, 
                llm=llm, 
                agents=agents, 
                name='host'
            )
            self.strategies['auto'] = AutoSelectionStrategy(self.host)
        
        self.agent_selection_method = agent_selection_method
        self._agents = agents
    
    def _select_agent(self, messages, mentioned_agents_name, lang):
        """选择智能体"""
        strategy = self.strategies[self.agent_selection_method]
        return strategy.select_agent(self._agents, messages, mentioned_agents_name, lang=lang)
```

#### 4.1.2 RAG 检索策略

```python
# qwen_agent/memory/rag_strategies.py
from abc import ABC, abstractmethod
from typing import List, Dict, Any

class RetrievalStrategy(ABC):
    """检索策略抽象基类"""
    
    @abstractmethod
    def retrieve(self, query: str, documents: List[str], top_k: int = 10) -> List[Dict[str, Any]]:
        """检索相关文档"""
        raise NotImplementedError

class KeywordRetrievalStrategy(RetrievalStrategy):
    """关键词检索策略"""
    
    def __init__(self, keyword_extractor):
        self.keyword_extractor = keyword_extractor
    
    def retrieve(self, query: str, documents: List[str], top_k: int = 10) -> List[Dict[str, Any]]:
        """基于关键词检索"""
        # 提取查询关键词
        keywords = self.keyword_extractor.extract(query)
        
        # 计算文档得分
        scored_docs = []
        for doc in documents:
            score = self._calculate_keyword_score(keywords, doc)
            scored_docs.append({'document': doc, 'score': score, 'strategy': 'keyword'})
        
        # 排序并返回 top_k
        scored_docs.sort(key=lambda x: x['score'], reverse=True)
        return scored_docs[:top_k]
    
    def _calculate_keyword_score(self, keywords: List[str], document: str) -> float:
        """计算关键词得分"""
        doc_lower = document.lower()
        score = 0
        
        for keyword in keywords:
            if keyword.lower() in doc_lower:
                score += 1
        
        return score

class VectorRetrievalStrategy(RetrievalStrategy):
    """向量检索策略"""
    
    def __init__(self, embedding_model, vector_index):
        self.embedding_model = embedding_model
        self.vector_index = vector_index
    
    def retrieve(self, query: str, documents: List[str], top_k: int = 10) -> List[Dict[str, Any]]:
        """基于向量检索"""
        # 计算查询向量
        query_vector = self.embedding_model.embed(query)
        
        # 向量搜索
        search_results = self.vector_index.search(query_vector, top_k)
        
        # 格式化结果
        results = []
        for result in search_results:
            results.append({
                'document': documents[result['index']],
                'score': result['score'],
                'strategy': 'vector'
            })
        
        return results

class HybridRetrievalStrategy(RetrievalStrategy):
    """混合检索策略"""
    
    def __init__(self, keyword_strategy: RetrievalStrategy, vector_strategy: RetrievalStrategy):
        self.keyword_strategy = keyword_strategy
        self.vector_strategy = vector_strategy
    
    def retrieve(self, query: str, documents: List[str], top_k: int = 10) -> List[Dict[str, Any]]:
        """混合检索"""
        # 并行执行两种检索
        with ThreadPoolExecutor(max_workers=2) as executor:
            keyword_future = executor.submit(self.keyword_strategy.retrieve, query, documents, top_k)
            vector_future = executor.submit(self.vector_strategy.retrieve, query, documents, top_k)
            
            keyword_results = keyword_future.result()
            vector_results = vector_future.result()
        
        # 融合结果
        fused_results = self._fusion_results(keyword_results, vector_results, top_k)
        return fused_results
    
    def _fusion_results(self, keyword_results: List[Dict], vector_results: List[Dict], top_k: int) -> List[Dict]:
        """融合检索结果"""
        # 使用 Reciprocal Rank Fusion (RRF)
        scores = {}
        
        # 关键词搜索得分
        for i, result in enumerate(keyword_results):
            doc_id = id(result['document'])
            scores[doc_id] = scores.get(doc_id, 0) + 1.0 / (i + 60)
        
        # 向量搜索得分
        for i, result in enumerate(vector_results):
            doc_id = id(result['document'])
            scores[doc_id] = scores.get(doc_id, 0) + 1.0 / (i + 60)
        
        # 排序并返回结果
        sorted_docs = sorted(scores.items(), key=lambda x: x[1], reverse=True)
        
        final_results = []
        for doc_id, score in sorted_docs[:top_k]:
            # 找到对应的文档
            doc = None
            for result in keyword_results + vector_results:
                if id(result['document']) == doc_id:
                    doc = result['document']
                    break
            
            if doc:
                final_results.append({
                    'document': doc,
                    'score': score,
                    'strategy': 'hybrid'
                })
        
        return final_results
```

### 4.2 观察者模式

#### 4.2.1 消息流观察者

```python
# qwen_agent/agents/observer.py
from abc import ABC, abstractmethod
from typing import List, Callable, Any
from dataclasses import dataclass

@dataclass
class MessageEvent:
    """消息事件"""
    event_type: str  # 'message_start', 'message_content', 'message_end'
    message: 'Message'
    timestamp: float
    metadata: Dict[str, Any] = None

class MessageObserver(ABC):
    """消息观察者抽象基类"""
    
    @abstractmethod
    def on_message_event(self, event: MessageEvent):
        """处理消息事件"""
        pass

class LoggingObserver(MessageObserver):
    """日志观察者"""
    
    def __init__(self, logger):
        self.logger = logger
    
    def on_message_event(self, event: MessageEvent):
        """记录消息事件"""
        self.logger.info(f"Message Event: {event.event_type} - {event.message.role}")
        
        if event.event_type == 'message_content':
            content = MessageAdapter.adapt_content_format(event.message.content)
            self.logger.debug(f"Content: {content[:100]}...")

class MetricsObserver(MessageObserver):
    """指标观察者"""
    
    def __init__(self):
        self.metrics = {
            'message_count': 0,
            'total_tokens': 0,
            'response_times': []
        }
    
    def on_message_event(self, event: MessageEvent):
        """收集性能指标"""
        if event.event_type == 'message_end':
            self.metrics['message_count'] += 1
            
            # 计算响应时间
            if event.metadata and 'response_time' in event.metadata:
                self.metrics['response_times'].append(event.metadata['response_time'])
            
            # 统计 token 数
            if event.metadata and 'token_count' in event.metadata:
                self.metrics['total_tokens'] += event.metadata['token_count']

class ObservableAgent:
    """可观察的智能体"""
    
    def __init__(self, agent: 'Agent'):
        self.agent = agent
        self.observers: List[MessageObserver] = []
    
    def add_observer(self, observer: MessageObserver):
        """添加观察者"""
        self.observers.append(observer)
    
    def remove_observer(self, observer: MessageObserver):
        """移除观察者"""
        self.observers.remove(observer)
    
    def _notify_observers(self, event: MessageEvent):
        """通知所有观察者"""
        for observer in self.observers:
            try:
                observer.on_message_event(event)
            except Exception as e:
                # 防止观察者异常影响主流程
                print(f"Observer error: {e}")
    
    def run(self, messages: List['Message'], **kwargs):
        """运行智能体并发送事件"""
        # 发送开始事件
        start_event = MessageEvent(
            event_type='message_start',
            message=Message(role='system', content='Processing started'),
            timestamp=time.time()
        )
        self._notify_observers(start_event)
        
        start_time = time.time()
        
        # 执行智能体逻辑
        for response in self.agent.run(messages, **kwargs):
            # 发送内容事件
            for msg in response:
                content_event = MessageEvent(
                    event_type='message_content',
                    message=msg,
                    timestamp=time.time(),
                    metadata={'response_time': time.time() - start_time}
                )
                self._notify_observers(content_event)
            
            yield response
        
        # 发送结束事件
        end_event = MessageEvent(
            event_type='message_end',
            message=Message(role='system', content='Processing completed'),
            timestamp=time.time(),
            metadata={'response_time': time.time() - start_time}
        )
        self._notify_observers(end_event)
```

### 4.3 命令模式

#### 4.3.1 工具调用命令

```python
# qwen_agent/agents/command.py
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional

class ToolCommand(ABC):
    """工具调用命令抽象基类"""
    
    @abstractmethod
    def execute(self, params: Dict[str, Any]) -> Any:
        """执行命令"""
        pass
    
    @abstractmethod
    def undo(self) -> bool:
        """撤销命令"""
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        """命令描述"""
        pass

class CodeExecutionCommand(ToolCommand):
    """代码执行命令"""
    
    def __init__(self, code_interpreter):
        self.code_interpreter = code_interpreter
        self.execution_result = None
    
    def execute(self, params: Dict[str, Any]) -> Any:
        """执行代码"""
        code = params.get('code', '')
        self.execution_result = self.code_interpreter.execute(code)
        return self.execution_result
    
    def undo(self) -> bool:
        """撤销代码执行（清理环境）"""
        if self.execution_result:
            # 清理执行环境
            self.code_interpreter.cleanup()
            self.execution_result = None
            return True
        return False
    
    @property
    def description(self) -> str:
        return "Execute Python code in a sandboxed environment"

class WebSearchCommand(ToolCommand):
    """网络搜索命令"""
    
    def __init__(self, search_engine):
        self.search_engine = search_engine
        self.search_results = None
    
    def execute(self, params: Dict[str, Any]) -> Any:
        """执行网络搜索"""
        query = params.get('query', '')
        self.search_results = self.search_engine.search(query)
        return self.search_results
    
    def undo(self) -> bool:
        """撤销搜索（清理缓存）"""
        if self.search_results:
            self.search_engine.clear_cache()
            self.search_results = None
            return True
        return False
    
    @property
    def description(self) -> str:
        return "Search the web for information"

class ToolCommandInvoker:
    """工具调用命令调用器"""
    
    def __init__(self):
        self.command_history: List[ToolCommand] = []
        self.undo_stack: List[ToolCommand] = []
    
    def execute_command(self, command: ToolCommand, params: Dict[str, Any]) -> Any:
        """执行命令"""
        try:
            result = command.execute(params)
            self.command_history.append(command)
            self.undo_stack.clear()  # 清空撤销栈
            return result
        except Exception as e:
            raise Exception(f"Command execution failed: {e}")
    
    def undo_last_command(self) -> bool:
        """撤销最后一个命令"""
        if not self.command_history:
            return False
        
        last_command = self.command_history.pop()
        success = last_command.undo()
        
        if success:
            self.undo_stack.append(last_command)
        
        return success
    
    def redo_last_command(self, params: Dict[str, Any]) -> Any:
        """重做最后一个撤销的命令"""
        if not self.undo_stack:
            return None
        
        command = self.undo_stack.pop()
        result = command.execute(params)
        self.command_history.append(command)
        return result
    
    def get_command_history(self) -> List[Dict[str, Any]]:
        """获取命令历史"""
        return [
            {
                'command': cmd.description,
                'timestamp': time.time(),
                'can_undo': True
            }
            for cmd in self.command_history
        ]
```

### 4.4 状态模式

#### 4.4.1 智能体状态管理

```python
# qwen_agent/agents/state.py
from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, Any

class AgentState(Enum):
    """智能体状态枚举"""
    IDLE = "idle"
    THINKING = "thinking"
    EXECUTING = "executing"
    WAITING = "waiting"
    ERROR = "error"

class AgentStateContext:
    """智能体状态上下文"""
    
    def __init__(self):
        self._state = IdleState()
        self._history = []
        self._metadata = {}
    
    def transition_to(self, state: 'AgentStateInterface'):
        """转换到新状态"""
        if self._state:
            self._state.exit(self)
        
        self._state = state
        self._state.enter(self)
        self._history.append(state.__class__.__name__)
    
    def handle_message(self, message: 'Message'):
        """处理消息"""
        self._state.handle_message(self, message)
    
    def handle_tool_result(self, result: Any):
        """处理工具结果"""
        self._state.handle_tool_result(self, result)
    
    def handle_error(self, error: Exception):
        """处理错误"""
        self._state.handle_error(self, error)
    
    @property
    def current_state(self) -> str:
        """获取当前状态"""
        return self._state.__class__.__name__
    
    @property
    def state_history(self) -> List[str]:
        """获取状态历史"""
        return self._history.copy()
    
    def set_metadata(self, key: str, value: Any):
        """设置元数据"""
        self._metadata[key] = value
    
    def get_metadata(self, key: str) -> Any:
        """获取元数据"""
        return self._metadata.get(key)

class AgentStateInterface(ABC):
    """智能体状态接口"""
    
    @abstractmethod
    def enter(self, context: AgentStateContext):
        """进入状态"""
        pass
    
    @abstractmethod
    def exit(self, context: AgentStateContext):
        """退出状态"""
        pass
    
    @abstractmethod
    def handle_message(self, context: AgentStateContext, message: 'Message'):
        """处理消息"""
        pass
    
    @abstractmethod
    def handle_tool_result(self, context: AgentStateContext, result: Any):
        """处理工具结果"""
        pass
    
    @abstractmethod
    def handle_error(self, context: AgentStateContext, error: Exception):
        """处理错误"""
        pass

class IdleState(AgentStateInterface):
    """空闲状态"""
    
    def enter(self, context: AgentStateContext):
        context.set_metadata('state_start_time', time.time())
        print("Agent entered idle state")
    
    def exit(self, context: AgentStateContext):
        print("Agent exited idle state")
    
    def handle_message(self, context: AgentStateContext, message: 'Message'):
        # 收到消息，转换为思考状态
        context.transition_to(ThinkingState())
    
    def handle_tool_result(self, context: AgentStateContext, result: Any):
        # 空闲状态下不应收到工具结果
        pass
    
    def handle_error(self, context: AgentStateContext, error: Exception):
        context.transition_to(ErrorState())

class ThinkingState(AgentStateInterface):
    """思考状态"""
    
    def enter(self, context: AgentStateContext):
        context.set_metadata('state_start_time', time.time())
        print("Agent started thinking")
    
    def exit(self, context: AgentStateContext):
        print("Agent finished thinking")
    
    def handle_message(self, context: AgentStateContext, message: 'Message'):
        # 思考状态下处理新消息
        print("Processing new message while thinking")
    
    def handle_tool_result(self, context: AgentStateContext, result: Any):
        # 收到工具结果，转换为执行状态
        context.transition_to(ExecutingState())
    
    def handle_error(self, context: AgentStateContext, error: Exception):
        context.transition_to(ErrorState())

class ExecutingState(AgentStateInterface):
    """执行状态"""
    
    def enter(self, context: AgentStateContext):
        context.set_metadata('state_start_time', time.time())
        print("Agent started executing")
    
    def exit(self, context: AgentStateContext):
        print("Agent finished executing")
    
    def handle_message(self, context: AgentStateContext, message: 'Message'):
        # 执行状态下处理新消息
        print("Received new message during execution")
    
    def handle_tool_result(self, context: AgentStateContext, result: Any):
        # 继续执行或完成
        if self._is_execution_complete(result):
            context.transition_to(IdleState())
        else:
            print("Continuing execution")
    
    def handle_error(self, context: AgentStateContext, error: Exception):
        context.transition_to(ErrorState())
    
    def _is_execution_complete(self, result: Any) -> bool:
        """判断执行是否完成"""
        # 根据结果判断执行状态
        return True

class WaitingState(AgentStateInterface):
    """等待状态"""
    
    def enter(self, context: AgentStateContext):
        context.set_metadata('state_start_time', time.time())
        print("Agent entered waiting state")
    
    def exit(self, context: AgentStateContext):
        print("Agent exited waiting state")
    
    def handle_message(self, context: AgentStateContext, message: 'Message'):
        # 等待状态下收到消息，转换为思考状态
        context.transition_to(ThinkingState())
    
    def handle_tool_result(self, context: AgentStateContext, result: Any):
        # 收到等待的工具结果
        context.transition_to(ThinkingState())
    
    def handle_error(self, context: AgentStateContext, error: Exception):
        context.transition_to(ErrorState())

class ErrorState(AgentStateInterface):
    """错误状态"""
    
    def enter(self, context: AgentStateContext):
        context.set_metadata('state_start_time', time.time())
        context.set_metadata('error_occurred', True)
        print("Agent entered error state")
    
    def exit(self, context: AgentStateContext):
        print("Agent recovered from error state")
    
    def handle_message(self, context: AgentStateContext, message: 'Message'):
        # 错误状态下收到消息，尝试恢复
        context.transition_to(IdleState())
    
    def handle_tool_result(self, context: AgentStateContext, result: Any):
        # 错误状态下忽略工具结果
        pass
    
    def handle_error(self, context: AgentStateContext, error: Exception):
        # 已经在错误状态，记录新错误
        print(f"Additional error occurred: {error}")
```

### 4.5 模板方法模式

#### 4.5.1 智能体执行模板

```python
# qwen_agent/agents/template.py
from abc import ABC, abstractmethod
from typing import Iterator, List, Optional

class AgentTemplate(ABC):
    """智能体模板基类"""
    
    def run(self, messages: List['Message'], **kwargs) -> Iterator[List['Message']]:
        """智能体执行模板方法"""
        try:
            # 1. 前置处理
            processed_messages = self.preprocess_messages(messages)
            
            # 2. 验证输入
            self.validate_input(processed_messages)
            
            # 3. 执行核心逻辑
            yield from self.execute_core(processed_messages, **kwargs)
            
            # 4. 后置处理
            yield from self.postprocess_results()
            
        except Exception as e:
            # 5. 错误处理
            yield from self.handle_error(e)
    
    def preprocess_messages(self, messages: List['Message']) -> List['Message']:
        """前置处理 - 可重写"""
        # 消息格式标准化
        standardized_messages = []
        for msg in messages:
            if isinstance(msg, dict):
                standardized_messages.append(Message(**msg))
            else:
                standardized_messages.append(msg)
        
        return standardized_messages
    
    def validate_input(self, messages: List['Message']):
        """验证输入 - 可重写"""
        if not messages:
            raise ValueError("Messages cannot be empty")
        
        for msg in messages:
            if not hasattr(msg, 'role') or not msg.role:
                raise ValueError("Message must have a role")
    
    @abstractmethod
    def execute_core(self, messages: List['Message'], **kwargs) -> Iterator[List['Message']]:
        """核心执行逻辑 - 必须实现"""
        raise NotImplementedError
    
    def postprocess_results(self) -> Iterator[List['Message']]:
        """后置处理 - 可重写"""
        # 默认无后置处理
        return iter([])
    
    def handle_error(self, error: Exception) -> Iterator[List['Message']]:
        """错误处理 - 可重写"""
        error_message = Message(
            role='assistant',
            content=f"An error occurred: {str(error)}"
        )
        yield [error_message]

class TemplateAssistant(AgentTemplate):
    """基于模板的助手智能体"""
    
    def __init__(self, llm, function_list=None, system_message=None):
        self.llm = llm
        self.function_list = function_list or []
        self.system_message = system_message
    
    def execute_core(self, messages: List['Message'], **kwargs) -> Iterator[List['Message']]:
        """执行核心逻辑"""
        # 1. 添加系统消息
        if self.system_message:
            system_msg = Message(role='system', content=self.system_message)
            messages = [system_msg] + messages
        
        # 2. 调用 LLM
        response_stream = self.llm.chat(
            messages=messages,
            functions=self.function_list,
            stream=True,
            **kwargs
        )
        
        # 3. 处理响应
        for response in response_stream:
            yield response
    
    def preprocess_messages(self, messages: List['Message']) -> List['Message']:
        """重写前置处理"""
        processed_messages = super().preprocess_messages(messages)
        
        # 添加自定义处理逻辑
        for msg in processed_messages:
            if msg.role == 'user':
                # 处理用户消息的特殊逻辑
                msg.content = self._preprocess_user_content(msg.content)
        
        return processed_messages
    
    def _preprocess_user_content(self, content) -> str:
        """预处理用户内容"""
        if isinstance(content, list):
            # 多模态内容处理
            text_parts = []
            for item in content:
                if item.type == 'text':
                    text_parts.append(item.text)
                else:
                    text_parts.append(f"[{item.type.upper()}]")
            return ' '.join(text_parts)
        
        return str(content)
```

## 5. 设计模式优势总结

### 5.1 架构优势

**模块化设计**:
- 各模式职责明确，模块间低耦合
- 易于测试和维护
- 支持组件独立演进

**扩展性强**:
- 策略模式支持算法动态切换
- 工厂模式支持新组件快速集成
- 装饰器模式支持功能透明扩展

**代码复用**:
- 模板方法提供通用执行流程
- 抽象工厂定义统一接口
- 外观模式简化复杂操作

### 5.2 开发效率

**开发效率**:
- 设计模式提供成熟解决方案
- 减少重复代码编写
- 统一的编码规范

**维护成本**:
- 清晰的代码结构
- 模块间低耦合
- 易于定位和修复问题

**学习曲线**:
- 标准化设计模式
- 完善的文档支持
- 丰富的示例代码

### 5.3 性能优化

**运行时性能**:
- 缓存模式减少重复计算
- 对象池模式优化资源使用
- 延迟初始化减少启动时间

**开发时性能**:
- 快速原型开发
- 组件复用和组合
- 自动化测试支持

## 6. 最佳实践建议

### 6.1 设计模式选择

**创建型模式**:
- 使用工厂模式创建复杂对象
- 使用建造者模式构建复杂配置
- 使用单例模式管理全局资源

**结构型模式**:
- 使用装饰器模式扩展功能
- 使用适配器模式兼容不同接口
- 使用外观模式简化复杂系统

**行为型模式**:
- 使用策略模式实现算法切换
- 使用观察者模式实现事件通知
- 使用命令模式封装操作

### 6.2 实施建议

**渐进式应用**:
- 从简单模式开始
- 逐步引入复杂模式
- 保持代码可读性

**团队协作**:
- 建立设计模式规范
- 代码审查和分享
- 持续学习和改进

**性能考量**:
- 避免过度设计
- 平衡复杂性和性能
- 定期重构优化

通过合理应用这些设计模式，Qwen-Agent 实现了一个功能强大、扩展性好、易于维护的企业级 LLM 应用开发框架。这些模式不仅解决了复杂的软件设计问题，还为框架的长期演进提供了坚实的基础。